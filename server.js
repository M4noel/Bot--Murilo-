import express from 'express';
import axios from 'axios';
import dotenv from 'dotenv';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import cors from 'cors';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Armazenar mensagens em mem√≥ria (em produ√ß√£o, use um banco de dados)
let messageHistory = [];
let lastUpdateId = 0;
// Armazenar conversas por sess√£o (m√∫ltiplos usu√°rios)
let conversations = {}; // { sessionId: { userName, userPhone, messages: [] } }
// Controle de conversa ativa (apenas 1 por vez)
let activeConversation = null; // sessionId da conversa ativa
let waitingQueue = []; // Fila de espera

app.use(express.json());
app.use(cors()); // Permitir requisi√ß√µes do frontend

// Fun√ß√µes auxiliares para comandos do Telegram
async function handleEndCommand(token, chatId) {
  if (!activeConversation) {
    await axios.post(`https://api.telegram.org/bot${token}/sendMessage`, {
      chat_id: chatId,
      text: '‚ùå Nenhuma conversa ativa no momento.',
      parse_mode: 'Markdown'
    });
    return;
  }

  const endedSession = activeConversation;
  const endedUser = conversations[endedSession];
  
  // Marcar como encerrada
  if (conversations[endedSession]) {
    conversations[endedSession].status = 'ended';
  }
  
  // Limpar conversa ativa
  activeConversation = null;
  
  // Ativar pr√≥ximo da fila
  let nextUser = null;
  if (waitingQueue.length > 0) {
    const nextSession = waitingQueue.shift();
    activeConversation = nextSession;
    if (conversations[nextSession]) {
      conversations[nextSession].status = 'active';
      nextUser = conversations[nextSession];
    }
  }
  
  let message = `‚úÖ *Conversa encerrada!*\n\n`;
  message += `üë§ Encerrado: ${endedUser.userName}\n`;
  message += `üìû Telefone: ${endedUser.userPhone}\n\n`;
  
  if (nextUser) {
    message += `üîÑ *Pr√≥ximo da fila ativado:*\n`;
    message += `üë§ ${nextUser.userName}\n`;
    message += `üìû ${nextUser.userPhone}\n`;
    message += `üí¨ ${nextUser.messages.length} mensagem(ns)\n\n`;
    message += `Agora voc√™ pode responder para ${nextUser.userName}!`;
  } else {
    message += `üì≠ Nenhuma pessoa na fila.`;
  }
  
  await axios.post(`https://api.telegram.org/bot${token}/sendMessage`, {
    chat_id: chatId,
    text: message,
    parse_mode: 'Markdown'
  });
}

async function handleQueueCommand(token, chatId) {
  let message = `üìã *FILA DE ATENDIMENTO*\n\n`;
  
  if (activeConversation && conversations[activeConversation]) {
    const active = conversations[activeConversation];
    message += `üü¢ *Conversa Ativa:*\n`;
    message += `üë§ ${active.userName}\n`;
    message += `üìû ${active.userPhone}\n`;
    message += `üí¨ ${active.messages.length} mensagem(ns)\n\n`;
  } else {
    message += `üü¢ Nenhuma conversa ativa\n\n`;
  }
  
  if (waitingQueue.length > 0) {
    message += `‚è≥ *Aguardando (${waitingQueue.length}):*\n`;
    waitingQueue.forEach((sessionId, index) => {
      const user = conversations[sessionId];
      if (user) {
        message += `${index + 1}. ${user.userName} - ${user.userPhone}\n`;
        message += `   üí¨ ${user.messages.length} mensagem(ns)\n`;
      }
    });
  } else {
    message += `üì≠ Nenhuma pessoa na fila`;
  }
  
  await axios.post(`https://api.telegram.org/bot${token}/sendMessage`, {
    chat_id: chatId,
    text: message,
    parse_mode: 'Markdown'
  });
}

async function handleClearAllCommand(token, chatId) {
  const totalConversations = Object.keys(conversations).length;
  const queueLength = waitingQueue.length;
  const activeUser = activeConversation && conversations[activeConversation] 
    ? conversations[activeConversation].userName 
    : null;
  
  // Marcar todas as conversas como encerradas
  Object.keys(conversations).forEach(sessionId => {
    if (conversations[sessionId]) {
      conversations[sessionId].status = 'ended';
    }
  });
  
  // Limpar conversa ativa e fila
  activeConversation = null;
  waitingQueue = [];
  
  let message = `üßπ *TODAS AS CONVERSAS ENCERRADAS*\n\n`;
  message += `‚úÖ Total encerrado: ${totalConversations} conversa(s)\n`;
  
  if (activeUser) {
    message += `üü¢ Ativa: ${activeUser}\n`;
  }
  
  if (queueLength > 0) {
    message += `‚è≥ Na fila: ${queueLength} pessoa(s)\n`;
  }
  
  message += `\nüì≠ Sistema limpo e pronto para novos atendimentos!`;
  
  await axios.post(`https://api.telegram.org/bot${token}/sendMessage`, {
    chat_id: chatId,
    text: message,
    parse_mode: 'Markdown'
  });
}

// Rota para enviar mensagem do site para o Telegram
app.post('/api/send', async (req, res) => {
  const TELEGRAM_TOKEN = process.env.TELEGRAM_TOKEN;
  const CHAT_ID = process.env.TELEGRAM_CHAT_ID;
  const { message, userName, userPhone, sessionId, timestamp } = req.body;

  console.log('üì® Nova mensagem recebida:', { message, userName, userPhone, sessionId });

  if (!TELEGRAM_TOKEN || !CHAT_ID) {
    return res.status(500).json({ 
      success: false, 
      error: "Vari√°veis de ambiente n√£o configuradas" 
    });
  }

  if (!message) {
    return res.status(400).json({ 
      success: false, 
      error: "Mensagem n√£o pode estar vazia" 
    });
  }

  try {
    // Criar ou atualizar conversa
    if (!conversations[sessionId]) {
      conversations[sessionId] = {
        userName: userName || 'Visitante',
        userPhone: userPhone || 'N√£o informado',
        messages: [],
        createdAt: Date.now(),
        status: 'waiting' // waiting, active, ended
      };
    }

    // Adicionar mensagem √† conversa
    conversations[sessionId].messages.push({
      text: message,
      isUser: true,
      timestamp: timestamp || Date.now()
    });

    // Verificar se h√° conversa ativa
    let messageStatus = '';
    let isFirstMessage = conversations[sessionId].messages.length === 1;
    let shouldNotifyUser = false;
    let userPosition = 0;
    
    if (!activeConversation && isFirstMessage) {
      // Primeira mensagem e nenhuma conversa ativa - ativar esta
      activeConversation = sessionId;
      conversations[sessionId].status = 'active';
      messageStatus = 'üü¢ *CONVERSA ATIVA* - Voc√™ pode responder agora!';
    } else if (activeConversation === sessionId) {
      // Continua√ß√£o da conversa ativa
      messageStatus = 'üü¢ *CONVERSA ATIVA*';
    } else if (activeConversation && activeConversation !== sessionId) {
      // H√° outra conversa ativa - colocar na fila
      if (!waitingQueue.includes(sessionId)) {
        waitingQueue.push(sessionId);
      }
      conversations[sessionId].status = 'waiting';
      const position = waitingQueue.indexOf(sessionId) + 1;
      userPosition = position;
      shouldNotifyUser = true;
      messageStatus = `‚è≥ *NA FILA* - Posi√ß√£o: ${position}\n_Esta pessoa est√° aguardando. Encerre a conversa atual para atend√™-la._`;
    }

    // Formatar mensagem para o Telegram com identifica√ß√£o √∫nica
    const formattedMessage = `
üí¨ *NOVA MENSAGEM*

${messageStatus}

üë§ *Nome:* ${userName || 'Visitante'}
üìû *Telefone:* ${userPhone || 'N√£o informado'}
üÜî *ID:* \`${sessionId}\`
üìÖ *Data:* ${new Date(timestamp).toLocaleString('pt-BR')}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìù *MENSAGEM:*
${message}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üí° *Comandos:*
‚Ä¢ Responda normalmente para continuar
‚Ä¢ \`/encerrar\` - Finaliza e atende pr√≥ximo da fila
‚Ä¢ \`/fila\` - Ver quem est√° esperando
‚Ä¢ \`/limpar\` - Encerra TODAS as conversas
    `.trim();

    await axios.post(
      `https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage`,
      {
        chat_id: CHAT_ID,
        text: formattedMessage,
        parse_mode: 'Markdown'
      }
    );

    // Salvar mensagem no hist√≥rico geral
    messageHistory.push({
      id: Date.now(),
      text: message,
      isUser: true,
      timestamp: timestamp || Date.now(),
      userName: userName || 'Visitante',
      userPhone: userPhone || 'N√£o informado',
      sessionId: sessionId
    });

    // Se o usu√°rio est√° na fila, enviar notifica√ß√£o para ele
    let queueNotification = null;
    if (shouldNotifyUser && userPosition > 0) {
      const queueMessage = `‚è≥ Voc√™ est√° na fila de atendimento!\n\nüìç Posi√ß√£o: ${userPosition}\n\n‚è∞ Aguarde, em breve voc√™ ser√° atendido.`;
      
      // Adicionar mensagem autom√°tica √† conversa
      conversations[sessionId].messages.push({
        text: queueMessage,
        isUser: false,
        timestamp: Date.now(),
        isSystemMessage: true
      });
      
      queueNotification = queueMessage;
    }

    return res.status(200).json({ 
      success: true, 
      message: "Mensagem enviada com sucesso!",
      queueNotification: queueNotification,
      queuePosition: userPosition > 0 ? userPosition : null
    });
  } catch (error) {
    console.error("‚ùå Erro ao enviar mensagem:", error.response?.data || error.message);
    return res.status(500).json({ 
      success: false, 
      error: "Falha no envio da mensagem",
      details: error.response?.data || error.message
    });
  }
});

// Rota para buscar novas mensagens do Telegram (respostas para o usu√°rio)
app.get('/api/messages', async (req, res) => {
  const TELEGRAM_TOKEN = process.env.TELEGRAM_TOKEN;
  const CHAT_ID = process.env.TELEGRAM_CHAT_ID;
  const sessionId = req.query.sessionId;

  if (!TELEGRAM_TOKEN || !CHAT_ID) {
    return res.status(500).json({ 
      success: false, 
      error: "Vari√°veis de ambiente n√£o configuradas" 
    });
  }

  try {
    // Buscar atualiza√ß√µes do Telegram
    const response = await axios.get(
      `https://api.telegram.org/bot${TELEGRAM_TOKEN}/getUpdates`,
      {
        params: {
          offset: lastUpdateId + 1,
          timeout: 30
        }
      }
    );

    const updates = response.data.result || [];
    const newMessages = [];

    for (const update of updates) {
      if (update.message && update.message.chat.id.toString() === CHAT_ID) {
        const msg = update.message;
        
        // Atualizar lastUpdateId
        if (update.update_id > lastUpdateId) {
          lastUpdateId = update.update_id;
        }

        // Adicionar mensagem ao hist√≥rico se n√£o for do bot
        if (!msg.from.is_bot && msg.text) {
          // Processar comandos
          if (msg.text.startsWith('/encerrar')) {
            await handleEndCommand(TELEGRAM_TOKEN, CHAT_ID);
            continue;
          }
          
          if (msg.text.startsWith('/fila')) {
            await handleQueueCommand(TELEGRAM_TOKEN, CHAT_ID);
            continue;
          }
          
          if (msg.text.startsWith('/limpar')) {
            await handleClearAllCommand(TELEGRAM_TOKEN, CHAT_ID);
            continue;
          }

          // Enviar para a conversa ativa (n√£o importa o sessionId da requisi√ß√£o)
          const targetSession = activeConversation || sessionId;
          
          const newMsg = {
            id: msg.message_id,
            text: msg.text,
            isUser: false, // √â uma resposta do Murilo
            timestamp: msg.date * 1000,
            userName: msg.from.first_name,
            sessionId: targetSession
          };
          
          // Adicionar √† conversa ativa
          if (targetSession && conversations[targetSession]) {
            conversations[targetSession].messages.push({
              text: msg.text,
              isUser: false,
              timestamp: msg.date * 1000
            });
            
            console.log(`‚úÖ Mensagem adicionada √† conversa de ${conversations[targetSession].userName}`);
          }
          
          messageHistory.push(newMsg);
          
          // S√≥ retornar mensagem se for para a sess√£o que est√° pedindo
          if (targetSession === sessionId) {
            newMessages.push(newMsg);
          }
        }
      }
    }

    return res.status(200).json({ 
      success: true, 
      messages: newMessages,
      totalMessages: messageHistory.length
    });
  } catch (error) {
    console.error("‚ùå Erro ao buscar mensagens:", error.response?.data || error.message);
    return res.status(500).json({ 
      success: false, 
      error: "Falha ao buscar mensagens",
      details: error.response?.data || error.message
    });
  }
});

// Rota para encerrar conversa e atender pr√≥ximo da fila
app.post('/api/end-conversation', (req, res) => {
  if (!activeConversation) {
    return res.status(400).json({
      success: false,
      message: 'Nenhuma conversa ativa no momento'
    });
  }

  const endedSession = activeConversation;
  const endedUser = conversations[endedSession];

  // Marcar como encerrada
  if (conversations[endedSession]) {
    conversations[endedSession].status = 'ended';
  }

  // Limpar conversa ativa
  activeConversation = null;

  // Ativar pr√≥ximo da fila
  let nextUser = null;
  if (waitingQueue.length > 0) {
    const nextSession = waitingQueue.shift();
    activeConversation = nextSession;
    if (conversations[nextSession]) {
      conversations[nextSession].status = 'active';
      nextUser = conversations[nextSession];
    }
  }

  return res.status(200).json({
    success: true,
    message: 'Conversa encerrada',
    endedUser: endedUser ? endedUser.userName : null,
    nextUser: nextUser ? nextUser.userName : null,
    queueLength: waitingQueue.length
  });
});

// Rota para ver fila de espera
app.get('/api/queue', (req, res) => {
  const queue = waitingQueue.map((sessionId, index) => ({
    position: index + 1,
    sessionId,
    userName: conversations[sessionId]?.userName || 'Desconhecido',
    userPhone: conversations[sessionId]?.userPhone || 'N√£o informado',
    messageCount: conversations[sessionId]?.messages.length || 0
  }));

  return res.status(200).json({
    success: true,
    activeConversation: activeConversation ? {
      sessionId: activeConversation,
      userName: conversations[activeConversation]?.userName,
      userPhone: conversations[activeConversation]?.userPhone
    } : null,
    queue: queue,
    queueLength: queue.length
  });
});

// Rota para listar conversas ativas
app.get('/api/conversations', (req, res) => {
  const activeConversations = Object.keys(conversations).map(sessionId => ({
    sessionId,
    userName: conversations[sessionId].userName,
    userPhone: conversations[sessionId].userPhone,
    messageCount: conversations[sessionId].messages.length,
    lastMessage: conversations[sessionId].messages[conversations[sessionId].messages.length - 1],
    createdAt: conversations[sessionId].createdAt,
    status: conversations[sessionId].status
  }));

  return res.status(200).json({ 
    success: true, 
    conversations: activeConversations,
    total: activeConversations.length,
    activeConversation: activeConversation
  });
});

// Rota para obter hist√≥rico completo
app.get('/api/history', (req, res) => {
  return res.status(200).json({ 
    success: true, 
    messages: messageHistory
  });
});

// Rota para limpar hist√≥rico (√∫til para desenvolvimento)
app.delete('/api/history', (req, res) => {
  messageHistory = [];
  return res.status(200).json({ 
    success: true, 
    message: "Hist√≥rico limpo com sucesso"
  });
});

app.get('/api/send', async (req, res) => {
  // Redireciona GET para POST
  return app._router.handle({ ...req, method: 'POST' }, res);
});

app.listen(PORT, () => {
  console.log(`‚úÖ Servidor rodando em http://localhost:${PORT}`);
  console.log(`üì° API dispon√≠vel em http://localhost:${PORT}/api/send`);
  console.log(`üí¨ Chat API dispon√≠vel em http://localhost:${PORT}/api/messages`);
});
